[合集 - 技术札纪——有限硬件与无限计算的权衡艺术(47)](https://github.com)

[1.书本介绍：技术札纪——有限硬件与无限计算的权衡艺术07-24](https://github.com/poemyang/p/19002322)[2.书本大纲：从芯片、分布式到云计算AI时代07-25](https://github.com/poemyang/p/19004265)[3.我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？07-25](https://github.com/poemyang/p/19004704)[4.我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？07-28](https://github.com/poemyang/p/19008983)[5.为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”07-29](https://github.com/poemyang/p/19010948)[6.没有Happens-Before？你的多线程代码就是‘一锅粥’！07-30](https://github.com/poemyang/p/19012883)[7.Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法07-31](https://github.com/poemyang/p/19014740)[8.a+b=c，处理器一步搞定，Java虚拟机为啥要四步？08-01](https://github.com/poemyang/p/19016482)[9.“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？08-04](https://github.com/poemyang/p/19020937)[10.“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器08-05](https://github.com/poemyang/p/19022518)[11.Java编译器优化秘籍：字节码背后的IR魔法与常见技巧08-06](https://github.com/poemyang/p/19024509)[12.解锁硬件潜能：Java向量化计算，性能飙升W倍！08-07](https://github.com/poemyang/p/19026352)[13.new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析08-08](https://github.com/poemyang/p/19027777)[14.性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？08-11](https://github.com/poemyang/p/19031406)[15.从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？08-12](https://github.com/poemyang/p/19033086)[16.硬盘性能提升100倍的秘密：看懂顺序I/O的魔力08-14](https://github.com/poemyang/p/19038725)[17.十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解08-18](https://github.com/poemyang/p/19043960)[18.Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？08-21](https://github.com/poemyang/p/19050442)[19.千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！08-22](https://github.com/poemyang/p/19052513)[20.RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？08-27](https://github.com/poemyang/p/19060527)[21.从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新08-28](https://github.com/poemyang/p/19061836)[22.从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵08-29](https://github.com/poemyang/p/19063734)[23.站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准09-01](https://github.com/poemyang/p/19068100):[樱花宇宙机场](https://enhouse.org)[24.gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？09-03](https://github.com/poemyang/p/19071487)[25.从JSON到Protobuf，深入序列化方案的选型与原理09-04](https://github.com/poemyang/p/19073206)[26.“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门09-05](https://github.com/poemyang/p/19074847)[27.海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略09-08](https://github.com/poemyang/p/19079520)[28.“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”09-09](https://github.com/poemyang/p/19082361)[29.“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？09-12](https://github.com/poemyang/p/19087563)[30.“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？09-15](https://github.com/poemyang/p/19092154)[31.系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！09-18](https://github.com/poemyang/p/19097975)[32.技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？09-19](https://github.com/poemyang/p/19100196)[33.绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法09-20](https://github.com/poemyang/p/19101931)[34.从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？09-23](https://github.com/poemyang/p/19106679)[35.一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？09-24](https://github.com/poemyang/p/19108676)[36.从MESA模型到锁升级：synchronized性能逆袭的底层逻辑09-25](https://github.com/poemyang/p/19110705)[37.揭秘JUC：volatile与CAS，并发编程的两大基石09-27](https://github.com/poemyang/p/19114881)[38.“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论10-13](https://github.com/poemyang/p/19139419)[39.Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？10-14](https://github.com/poemyang/p/19142146)[40.“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学10-15](https://github.com/poemyang/p/19143895)[41.你的程序为何卡顿？从LINUX I/O三大模式寻找答案10-16](https://github.com/poemyang/p/19146666)[42.单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石10-17](https://github.com/poemyang/p/19148798)[43.从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构10-20](https://github.com/poemyang/p/19153675)[44.职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能10-21](https://github.com/poemyang/p/19156356)[45.“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河10-22](https://github.com/poemyang/p/19159101)[46.jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现10-23](https://github.com/poemyang/p/19160579)

47.为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念10-25

收起

在Java的编程世界里，开发者既无需也无法像C/C++那样手动调用malloc/free来管理内存的分配与回收，这一核心任务完全由Java虚拟机在幕后自动完成。这种自动化设计极大地简化了编码，将开发者从繁琐且极易出错的内存管理中解放出来。然而，这种便利性的背后隐藏着一个经典且复杂的难题：一个动态运行的程序，其对象创建和消亡的模式千变万化，Java虚拟机如何高效地追踪这些对象的生命周期，在正确的时间回收不再使用的内存，同时又不能过度影响程序的正常运行？这不仅是一个纯粹的技术挑战，更是一门关于平衡与取舍的系统设计艺术。本文将深入剖析Java虚拟机垃圾回收（Garbage Collection，GC）的核心逻辑，从底层的标记-清除算法到现代回收器的动态分区与并发策略，揭示自动化内存管理如何在程序响应速度（延迟）、内存空间利用率和计算资源吞吐量这三大核心指标之间实现精妙的平衡。

**垃圾回收：为何需要自动大扫除**
垃圾回收是一种自动化的内存管理机制。它的核心任务是自动追踪并回收那些在程序中已经不再被任何活动部分引用的内存空间，即“垃圾”，从而将这些宝贵的内存资源释放出来，以便后续的内存分配可以重新利用它们。
在许多高级编程语言（如Java、Python、C#、Golang等）中，开发者不需要（通常也不能）直接操作内存地址。内存的分配（创建对象时）和回收（对象不再使用时）都由语言的运行时系统（Runtime System）全权负责。这种自动化机制的初衷是为了从根本上避免一系列因手动内存管理而臭名昭著的严重问题：
1）内存泄漏（Memory Leak）：程序员分配了内存后，忘记在不再需要时释放它，导致可用内存随程序运行不断减少，最终耗尽系统资源，引发程序崩溃。
2）悬挂指针（Dangling Pointer）：一个指针继续指向一块已经被释放的内存区域。后续对该指针的任何读写操作都可能导致数据损坏、程序崩溃，甚至是严重的安全漏洞。
3）双重释放（Double Free）：程序试图对同一块内存区域执行两次释放操作。这会破坏内存管理器的内部数据结构，导致不可预测的后果。
虽然垃圾回收带来了巨大的编程便利性和系统稳定性，但它并非没有代价。其主要的挑战在于垃圾回收过程本身需要消耗计算资源，并且可能会导致应用程序的短暂暂停（Stop-the-world, STW），即所有业务线程被冻结。此外，垃圾回收触发的时机和持续时间在某种程度上是不可预测的，这为实时性和低延迟应用带来了挑战。

**垃圾回收的概念：对象、堆、根与分配**

**对象**
对象（Object），在不同的使用场合其意思各不相同。例如，在面向对象编程（Object-Oriented Programming，OOP）中，对象被定义为具有属性（也称为状态或字段）和行为（也称为方法或函数）的实体。然而，在垃圾回收中，对象通常指的是应用程序动态创建并使用的数据集合。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251025230701509-728410041.png)

通常，对象由两部分组成：头（Header）和域（Field）。
头是对象中存储对象自身信息的部分，主要包含对象的大小和类型。如果没有这些信息，那么将无法确定内存中对象的边界，这对垃圾回收至关重要。
此外，头部还预先存储了执行垃圾回收所需的信息，这些信息会根据垃圾回收算法的不同而不同。例如，在对象的头部设置一个标志位（flag）来记录对象是否已被标记，以便确定该对象是否可以被回收。
通常，垃圾回收算法中都会用到对象大小和类型信息。
域是对象中可供用户访问的部分，类似于C语言中的结构体成员。用户可以引用或修改对象的域值，但通常无法直接更改头部信息。
域中的数据类型主要分为两类：非指针和指针。非指针类型是指直接使用的值，如数字、字符和布尔值。指针类型则是指向内存空间中某个区域的值。对于使用过C或C++的读者来说，对指针应该非常熟悉。即使在像Java这样的编程语言中，用户并未明确使用指针，但在Java虚拟机内部，指针仍然被使用。
在大多数语言的运行程序中，指针默认指向对象的首地址。这个约束条件简化了垃圾回收以及语言处理程序的其他各种处理过程。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251025230714072-1549938793.png)

**堆**
堆（Heap）是一种动态内存分配的数据结构。它允许程序在运行时请求并释放内存。这与栈（Stack）不同，栈是在程序编译时就已经分配好的内存空间。
当一个对象被创建（如通过new关键字或其他构造函数），系统会在堆内存中为其分配空间。这个对象将一直存在，直到没有引用指向它，此时，它将被视为垃圾。垃圾回收的目标是识别并释放这些无引用的对象所占用的内存，以便这部分内存可以被重新分配。
当堆被所有活动对象占满时，就算运行垃圾回收也无法分配可用空间。通常，有以下两种选择：
1）中断当前程序运行，输出错误信息（例如OutOfMemoryError Exception）；
2）扩大堆，分配可用空间。
在实际运行环境中，应尽量避免因内存不足导致的程序中断。在没有特殊内存限制的情况下，应优先考虑扩展堆。
在垃圾回收中，分块（Chunk）指的是预先准备的用于有效分配对象的空间。初始状态下，堆被一个大的分块占据。然后，程序会根据运行环境的需求将这个分块划分为适当的大小。对象在一段时间后会变为垃圾并被回收。此时，这部分被回收的内存空间再次成为分块，为下次使用做好准备。换句话说，内存中的各个区块都在重复着分块->对象创建->垃圾回收->分块的循环过程。

**分配**
分配（Allocation）通常是指在堆内存中为对象分配空间的过程，主要有两种方式。
1）空闲链表（Free List）：在这种方法中，所有的空闲内存块通过链表连接在一起，每个空闲块包含指向下一空闲块的指针和大小信息。当需要分配内存时，系统遍历这个链表寻找合适的空闲块，并从链表中移除它；当内存块被释放时，它会被重新添加到链表中。这种方法可以处理任意大小的内存请求，但由于需要遍历链表，操作可能较慢。
![image]()

2）碰撞指针（Bump Pointer）：在这种方法中，系统维护一个指针，指向堆内存中的当前位置。当需要分配内存时，系统只需将碰撞指针向上移动相应的大小，然后返回原来的指针值即可。这个过程非常快，因为它只需要一次简单的指针加法操作。然而，碰撞指针的缺点是它不能直接处理内存释放。当内存块被释放时，除非它恰好位于堆的顶部，否则系统无法将其空间重新添加到可用内存中。因此，碰撞指针通常与其他内存管理技术（如垃圾回收）结合使用。
![image]()

**根**
根（Root）这个词的意思是根基或根底。在垃圾回收中，根是指向对象的指针的起点部分。

```
obj = Object.new
obj.field1 = Object.new
```

在如上伪代码中，obj是全局变量。首先，分配一个对象 (对象A)，然后把obj代入指向这个对象的指针。然后，再分配一个对象 (对象B)。然后把obj.field1代入指向这个对象的指针。此时，全局变量空间及堆如图所示。
![image]()

因为可以使用obj直接从伪代码中引用对象A，也就是说A是存活对象（活动对象）。此外，因为可以通过obj经由对象A引用对象B，所以对象B也是存活对象。因此垃圾回收必须保护这些对象。
垃圾回收把上述这样可以直接或间接从全局变量空间中引用的对象视为存活对象（活动对象），与之对应的是死亡对象（非活动对象）。

**Mutator**
在垃圾回收中，Mutator是指能够修改堆内存的代码部分。这些代码通常是应用程序的一部分，可以创建新对象、改变对象引用关系或释放对象。
Mutator在运行时会改变堆中的数据结构，这可能会影响哪些对象是存活的，哪些是死亡对象，可以被垃圾回收。
在垃圾回收过程中，需要暂停或监控Mutator的行为。这是因为如果在回收过程中，Mutator继续修改堆数据结构，可能导致内存处于不一致状态，例如将不再需要的对象误认为仍在使用。
因此，垃圾回收器和Mutator之间需要协调机制，以确保在回收过程中堆的数据结构保持一致。这通常通过暂停整个程序的方式或使用读写屏障（Read/Write Barrier）来实现。
![image]()

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**
